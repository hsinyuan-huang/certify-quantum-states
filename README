# Code and Data for the Manuscript: "Certifying Almost All Quantum States with Few Single-Qubit Measurements"

This project contains the code and data accompanying our paper "Certifying almost all quantum states with few single-qubit measurements". Our work introduces a new technique for certifying n-qubit quantum states using only few single-qubit measurements.

## Introduction

Certifying that an n-qubit state synthesized in a laboratory is close to the target state is a fundamental task in quantum information science. Our research proves that almost all n-qubit target states, including those with exponential circuit complexity, can be certified from only O(n^2) single-qubit measurements. This result is established by a new technique that relates certification to the mixing time of a random walk.

Our protocol has wide-ranging applications:
- Benchmarking quantum systems
- Optimizing quantum circuits to generate desired target states
- Learning and verifying neural networks, tensor networks, and various other representations of quantum states using only single-qubit measurements

Importantly, we show that certified representations of quantum systems can be used to efficiently predict highly non-local properties that would otherwise require an exponential number of measurements. Our numerical experiments, conducted with up to 120 qubits, demonstrate advantages over existing methods such as cross-entropy benchmarking (XEB).

This repository contains the code used to generate the results and figures in our paper, allowing for reproduction and further exploration of our findings.

## Project Structure

The project is divided into three main parts, each corresponding to a specific experiment and figure:

1. **benchmarking-vs-XEB/**
   - Compares shadow overlap vs XEB value, with fidelity as ground truth
   - Main script: `plot_Benchmark.py`
   - Main figure: `plots_benchmarking.pdf`

2. **neural-quantum-state/**
   - Demonstrates training and prediction performance of a neural network model for quantum systems
   - Main script: `plot_NN.py`
   - Main figure: `plots_NN.pdf`

3. **optim-state-prep/**
   - Shows quantum circuit optimization for state preparation using shadow overlap
   - Main script: `plot_MStatePrep.py`
   - Main figure: `plots_opt_state_prep.pdf`

## Requirements

### Python Dependencies
- Python 3.x
- numpy
- scipy
- pandas
- matplotlib
- seaborn

### C++ Dependencies
- g++ compiler (supporting C++11 standard)
- Armadillo linear algebra library

### System Requirements
- Make utility
- POSIX-compliant shell (for running shell commands from Python)

## Installation

1. Install Python dependencies:
   ```
   pip install numpy scipy pandas matplotlib seaborn
   ```

2. Install C++ dependencies:
   - Ensure you have g++ installed on your system
   - Install the Armadillo library:
     - On Ubuntu/Debian: `sudo apt-get install libarmadillo-dev`
     - On macOS with Homebrew: `brew install armadillo`
     - For other systems, please refer to the Armadillo documentation

## Usage

For each experiment, follow these steps:

1. Navigate to the respective directory (`benchmarking-vs-XEB/`, `neural-quantum-state/`, or `optim-state-prep/`).
2. Compile the C++ code by running:
   ```
   make
   ```
3. Run the Python script to generate plots:
   ```
   python plot_Benchmark.py  # for benchmarking-vs-XEB
   python plot_NN.py         # for neural-quantum-state
   python plot_MStatePrep.py # for optim-state-prep
   ```

### Executable Details

1. **benchmarking-vs-XEB/**
   - Executables: `XEBvsShadowFid-Haar`, `XEBvsShadowFid-Phase`, `XEBvsShadowFid-Haar-general-err`, `XEBvsShadowFid-Phase-general-err`, `XEBvsShadowFid-Haar-dephasing`, `XEBvsShadowFid-Phase-dephasing`
   - Usage details are in the corresponding C++ files and `plot_Benchmark.py`

2. **neural-quantum-state/**
   - Executable: `NN-learn`
   - Usage details are in `NN-learn.cpp` and `plot_NN.py`

3. **optim-state-prep/**
   - Executable: `StatePrep`
   - Usage details are in the corresponding C++ files and `plot_MStatePrep.py`

## Generating Final Plots

The individual plots generated by the Python scripts are combined using Omnigraffle in each directory to create the final PDF figures.

The individual plots generated by the Python scripts are combined to create the final PDF figures. In our workflow, we used Omnigraffle, a diagramming and graphic design software for macOS, to combine and arrange the plots. Each folder contains the corresponding `plots.graffle` for generating the final PDF figure. However, any similar software capable of combining and arranging images can be used for this purpose. Some alternatives include:

Adobe Illustrator
Inkscape (open-source)
Microsoft PowerPoint
GIMP (open-source)
Figma (web-based)

Choose the software you're most comfortable with or that best fits your operating system and needs.

## Note

Ensure all C++ source files and headers are in the same directory as the Makefile, and that Python scripts can access the compiled C++ executables.